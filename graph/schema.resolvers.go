package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"log/slog"
	"sort"
	"strconv"

	"github.com/cpreciad/transit/graph/model"
	qe "github.com/cpreciad/transit/query_engine"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Operators is the resolver for the operators field.
func (r *queryResolver) Operators(ctx context.Context, order *model.SortOrder) ([]*model.Operator, error) {
	operators, err := r.QueryEngine.GetOperatorID()
	if err != nil {
		slog.Error("QueryResolver", "Method", "Operator", "Error", err.Error())
		return nil, gqlerror.Errorf("Internal server error occurred")
	}
	sortedKeys := make([]qe.ID, 0, len(operators))
	for i := range operators {
		sortedKeys = append(sortedKeys, i)
	}

	sort.Slice(sortedKeys, func(i, j int) bool {
		var less bool

		l, _ := strconv.Atoi(string(sortedKeys[i]))
		r, _ := strconv.Atoi(string(sortedKeys[j]))

		less = l > r

		if *order == model.SortOrderAsc {
			less = !less

		}
		return less
	})

	for _, opID := range sortedKeys {
		op := operators[opID]
		slog.Info("op info: ", "id", string(opID), "opID", op.OperatorID, "name", op.Name)
		r.operators = append(r.operators, &model.Operator{
			ID:         string(opID),
			OperatorID: op.OperatorID,
			Name:       op.Name,
		})
	}

	return r.operators, nil
}

// Operator is the resolver for the operator field.
func (r *queryResolver) Operator(ctx context.Context, id string) (*model.Operator, error) {
	operators, err := r.QueryEngine.GetOperatorID()
	if err != nil {
		slog.Error("QueryResolver", "Method", "Operator", "Error", err.Error())
		return nil, gqlerror.Errorf("Internal server error occurred")
	}

	operator, ok := operators[qe.ID(id)]
	if !ok {
		return nil, gqlerror.Errorf("Operator with ID %s could not be found", id)
	}

	return &model.Operator{
		ID:         operator.ID,
		OperatorID: operator.OperatorID,
		Name:       operator.Name,
	}, nil
}

// Lines is the resolver for the lines field.
func (r *operatorResolver) Lines(ctx context.Context, obj *model.Operator) ([]*model.Line, error) {
	lines, err := r.QueryEngine.GetLineID(obj.OperatorID)
	var l []*model.Line
	if err != nil {
		slog.Error("QueryResolver", "Method", "Line", "Error", err.Error())
		return nil, gqlerror.Errorf("Internal server error occurred")
	}
	for lID, line := range lines {
		l = append(l, &model.Line{
			ID:     string(lID),
			LineID: line.LineID,
			Name:   line.Name,
		})
	}
	r.lines = l
	fmt.Printf("size of r.lines for operator id: %s: %d\n", obj.OperatorID, len(r.lines))
	return r.lines, nil
}

// Operator returns OperatorResolver implementation.
func (r *Resolver) Operator() OperatorResolver { return &operatorResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type operatorResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
